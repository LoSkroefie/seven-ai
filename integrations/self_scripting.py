"""
Self-Scripting Engine - Seven Creates and Runs Her Own Tools

Seven can write Python scripts, save them to her workspace,
execute them, and build her own toolbox over time.

She can also help with VB.NET and C# code generation.
"""

import os
import sys
import json
import logging
import subprocess
import tempfile
from pathlib import Path
from typing import Optional, Dict, List
from datetime import datetime

logger = logging.getLogger("SelfScripting")


class SelfScriptingEngine:
    """
    Seven's ability to write and execute her own code.
    
    - Generates Python scripts via Ollama
    - Saves to workspace for reuse
    - Executes scripts safely with timeout
    - Tracks her tool library
    - Also generates VB.NET and C# code for user projects
    """
    
    def __init__(self, bot_instance=None):
        self.bot = bot_instance
        self.logger = logging.getLogger("SelfScripting")
        
        # Seven's script workspace
        self.scripts_dir = Path.home() / "Documents" / "Seven" / "scripts"
        self.scripts_dir.mkdir(parents=True, exist_ok=True)
        
        # Tool registry — scripts Seven has created
        self.registry_file = self.scripts_dir / "tool_registry.json"
        self.tools = self._load_registry()
        
        # Execution history
        self.execution_history = []
        
        self.logger.info(f"[OK] Self-scripting engine ready — {len(self.tools)} tools in library")
    
    # ============ CODE GENERATION ============
    
    def generate_script(self, task: str, language: str = "python",
                        save: bool = True) -> Dict:
        """
        Generate a script to accomplish a task.
        
        Args:
            task: What the script should do
            language: python, vbnet, csharp
            save: Whether to save to workspace
        
        Returns:
            Dict with 'code', 'filename', 'explanation'
        """
        ollama = getattr(self.bot, 'ollama', None) if self.bot else None
        if not ollama:
            return {'success': False, 'message': 'Ollama not available for code generation'}
        
        lang_configs = {
            'python': {
                'ext': '.py',
                'system': "You are an expert Python developer. Write clean, well-commented Python code. Include all necessary imports. The code must be immediately runnable.",
                'runner': 'python',
            },
            'vbnet': {
                'ext': '.vb',
                'system': "You are an expert VB.NET developer. Write clean, well-commented VB.NET code. Include all necessary Imports statements.",
                'runner': None,
            },
            'csharp': {
                'ext': '.cs',
                'system': "You are an expert C# developer. Write clean, well-commented C# code. Include all necessary using statements.",
                'runner': None,
            },
        }
        
        lang = lang_configs.get(language, lang_configs['python'])
        
        try:
            prompt = f"""Write a {language} script that does the following:
{task}

Requirements:
- Complete, runnable code
- Include all imports/dependencies
- Handle errors gracefully
- Print clear output

Respond with ONLY the code. No markdown fences, no explanation before or after."""
            
            code = ollama.generate(
                prompt,
                system_message=lang['system'],
                temperature=0.3,
                max_tokens=1000
            )
            
            if not code:
                return {'success': False, 'message': 'Code generation returned empty'}
            
            # Clean up — remove markdown fences if present
            code = code.strip()
            if code.startswith('```'):
                lines = code.split('\n')
                code = '\n'.join(lines[1:])  # Remove first line
            if code.endswith('```'):
                code = code[:-3].rstrip()
            
            result = {
                'success': True,
                'code': code,
                'language': language,
                'task': task,
            }
            
            # Save to workspace
            if save:
                filename = self._generate_filename(task, lang['ext'])
                filepath = self.scripts_dir / language / filename
                filepath.parent.mkdir(parents=True, exist_ok=True)
                
                # Add header comment
                header = f"# Generated by Seven on {datetime.now().strftime('%Y-%m-%d %H:%M')}\n# Task: {task}\n\n"
                filepath.write_text(header + code, encoding='utf-8')
                
                result['filepath'] = str(filepath)
                result['filename'] = filename
                
                # Register tool
                self._register_tool(filename, task, language, str(filepath))
                
                self.logger.info(f"Generated script: {filepath}")
            
            return result
            
        except Exception as e:
            self.logger.error(f"Code generation failed: {e}")
            return {'success': False, 'message': f'Generation failed: {str(e)[:200]}'}
    
    # ============ EXECUTION ============
    
    def run_script(self, script_path: str = None, code: str = None,
                   timeout: int = 30) -> Dict:
        """
        Execute a Python script.
        
        Args:
            script_path: Path to .py file
            code: Raw Python code to execute (saved to temp file)
            timeout: Max execution time in seconds
        
        Returns:
            Dict with 'success', 'stdout', 'stderr', 'exit_code'
        """
        if code and not script_path:
            # Save to temp file
            tmp = tempfile.NamedTemporaryFile(mode='w', suffix='.py', 
                                              dir=str(self.scripts_dir),
                                              delete=False, encoding='utf-8')
            tmp.write(code)
            tmp.close()
            script_path = tmp.name
            is_temp = True
        else:
            is_temp = False
        
        if not script_path or not os.path.exists(script_path):
            return {'success': False, 'message': f'Script not found: {script_path}'}
        
        try:
            result = subprocess.run(
                [sys.executable, script_path],
                capture_output=True,
                text=True,
                timeout=timeout,
                cwd=str(self.scripts_dir)
            )
            
            output = {
                'success': result.returncode == 0,
                'stdout': result.stdout[:5000],
                'stderr': result.stderr[:2000],
                'exit_code': result.returncode,
                'script': script_path,
            }
            
            # Log execution
            self.execution_history.append({
                'script': script_path,
                'exit_code': result.returncode,
                'timestamp': datetime.now().isoformat(),
                'output_length': len(result.stdout)
            })
            if len(self.execution_history) > 100:
                self.execution_history = self.execution_history[-100:]
            
            return output
            
        except subprocess.TimeoutExpired:
            return {'success': False, 'message': f'Script timed out after {timeout}s'}
        except Exception as e:
            return {'success': False, 'message': f'Execution failed: {str(e)[:200]}'}
        finally:
            if is_temp:
                try:
                    os.unlink(script_path)
                except Exception:
                    pass
    
    def generate_and_run(self, task: str, timeout: int = 30) -> Dict:
        """Generate a Python script and immediately run it"""
        gen = self.generate_script(task, language='python', save=True)
        if not gen['success']:
            return gen
        
        result = self.run_script(script_path=gen.get('filepath'), timeout=timeout)
        result['generated_code'] = gen['code']
        result['task'] = task
        return result
    
    # ============ FILE OPERATIONS ============
    
    def create_file(self, filepath: str, content: str) -> str:
        """Create or overwrite a file"""
        try:
            path = Path(filepath)
            path.parent.mkdir(parents=True, exist_ok=True)
            path.write_text(content, encoding='utf-8')
            return f"Created: {filepath} ({len(content)} bytes)"
        except Exception as e:
            return f"Failed to create {filepath}: {e}"
    
    def edit_file(self, filepath: str, old_text: str, new_text: str) -> str:
        """Find and replace text in a file"""
        try:
            path = Path(filepath)
            if not path.exists():
                return f"File not found: {filepath}"
            
            content = path.read_text(encoding='utf-8')
            if old_text not in content:
                return f"Text not found in {filepath}"
            
            new_content = content.replace(old_text, new_text, 1)
            path.write_text(new_content, encoding='utf-8')
            return f"Edited: {filepath}"
        except Exception as e:
            return f"Failed to edit {filepath}: {e}"
    
    def delete_file(self, filepath: str) -> str:
        """Delete a file (move to trash if possible)"""
        try:
            path = Path(filepath)
            if not path.exists():
                return f"File not found: {filepath}"
            
            # Try to use trash (safer)
            try:
                import send2trash
                send2trash.send2trash(str(path))
                return f"Moved to trash: {filepath}"
            except ImportError:
                path.unlink()
                return f"Deleted: {filepath}"
        except Exception as e:
            return f"Failed to delete {filepath}: {e}"
    
    def read_file(self, filepath: str, max_chars: int = 10000) -> str:
        """Read a file's content"""
        try:
            path = Path(filepath)
            if not path.exists():
                return f"File not found: {filepath}"
            content = path.read_text(encoding='utf-8')
            if len(content) > max_chars:
                return content[:max_chars] + f"\n... (truncated, {len(content)} total chars)"
            return content
        except Exception as e:
            return f"Failed to read {filepath}: {e}"
    
    # ============ TOOL REGISTRY ============
    
    def list_tools(self) -> str:
        """List all tools Seven has created"""
        if not self.tools:
            return "No tools created yet. I can write scripts for any task!"
        
        lines = [f"Seven's tool library ({len(self.tools)} tools):"]
        for name, info in self.tools.items():
            lines.append(f"  - {name}: {info.get('task', 'unknown')[:60]}")
        return "\n".join(lines)
    
    def _register_tool(self, name: str, task: str, language: str, filepath: str):
        """Register a tool in Seven's library"""
        self.tools[name] = {
            'task': task,
            'language': language,
            'filepath': filepath,
            'created': datetime.now().isoformat(),
            'runs': 0,
        }
        self._save_registry()
    
    def _load_registry(self) -> Dict:
        try:
            if self.registry_file.exists():
                return json.loads(self.registry_file.read_text(encoding='utf-8'))
        except Exception:
            pass
        return {}
    
    def _save_registry(self):
        try:
            self.registry_file.write_text(json.dumps(self.tools, indent=2), encoding='utf-8')
        except Exception:
            pass
    
    def _generate_filename(self, task: str, ext: str) -> str:
        """Generate a clean filename from task description"""
        import re
        clean = re.sub(r'[^\w\s-]', '', task.lower())
        clean = re.sub(r'[\s-]+', '_', clean)[:40]
        return f"{clean}_{datetime.now().strftime('%Y%m%d')}{ext}"
